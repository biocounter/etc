#============================================================================
#title          :.bash_profile.sh
#description    :setup and customizations for bash shell
#author         :Gary Furash
#date           :20140422
#version        :1      
#usage          :./.bash_profile.sh
#notes          :       
#bash_version   :4.1.11(2)-release
#============================================================================

#-------------------------------------------------------------------------------
# Source global definitions (if any)
#-------------------------------------------------------------------------------
if [ -f /etc/bashrc ]; then
	. /etc/bashrc
fi
if [ -f /etc/profile ]; then
	. /etc/profile
fi

#-------------------------------------------------------------------------------
# Some settings
#-------------------------------------------------------------------------------

ulimit -S -c 0				# Don't want any coredumps
set -o notify
set -o noclobber
set -o ignoreeof
#set -o nounset				# error 'unbound variable' if expanded variable not set
set nocompatible
set nodosfilewarnings		# turn off dos file warnings
#set -o xtrace				# useful for debuging
set -o vi					# use VI for editing
							# k		previous command
							# j		next command
							# 0		start of command
							# $		end of command
# /,n,N search
export LC_ALL='C'			# sort ignores problem characters

# Enable options:
shopt -s cdspell
shopt -s cdable_vars
shopt -s checkhash
shopt -s checkwinsize
shopt -s sourcepath
shopt -s no_empty_cmd_completion         #bash>=2.04 only
shopt -s cmdhist
shopt -s histappend histreedit histverify
shopt -s extglob                         #necessary for programmable completion

if [[ ${BASH_VERSINFO[0]} == 4 ]]; then
shopt -s globstar                        #enable '**' (recursive)
fi

# use this section for variables that append
#if [ -z "$RANPROFILE" ]; then
#		export RANPROFILE=true
#fi

export TIMEFORMAT=$'\nreal %3R	user %3U	sys %3S	pcpu %P\n'
export HISTIGNORE="&:bg:fg:ll:h"
export HOSTFILE=$HOME/.hosts	# Put a list of remote hosts in ~/.hosts
export EDITOR=vi				# use the VI editor for line edting

#-------------------------------------------------------------------------------
# Environment Variables
#-------------------------------------------------------------------------------

function bashify {	# convert environment variable to cygwin format
	if [[ ${BASH_VERSINFO[5]} == *cygwin* ]]; then
		local p
		for p ; do
		 if [ "${!p}" ] ; then
			   eval 'export '$p'=$(cygpath -pu "$'$p'")'
		 fi
		done
	fi
}
export -f bashify

function addtopath { # add value to path if it does not exist
	local p=$1
	if [ -d "$p" ]; then
		if [[ ${BASH_VERSINFO[5]} == *cygwin* ]]; then
			p=`cygpath -pu $p`
		fi
		if [[ "${PATH}" != *:"${p}":* ]] ; then
			export PATH=$PATH:$p
		fi
	 fi
}
export -f addtopath

#include any local environment variables
if [ -f ~/.setenv ]; then
	. ~/.setenv
fi

addtopath /bin
addtopath /usr/sbin
addtopath /usr/local/bin
addtopath /usr/bin
addtopath ~/bin
bashify GIT_HOME
addtopath $GIT_HOME/bin
bashify JAVA_HOME
addtopath $JAVA_HOME/bin
addtopath $SCALA_HOME/bin

# configure python3 environment
#alias python=python3
#export PYTHONHOME=/usr/lib/python3.2:/usr/lib/python3.2/plat-cygwin:/usr/lib/python3.2/lib-tk:/usr/lib/python3.2/lib-dynload:/usr/lib/python3.2/site-packages

# include any windows-specific environment variables
if [[ ${BASH_VERSINFO[5]} == *cygwin* ]]; then
	addtopath /cygdrive/c/Windows/SysWOW64
	addtopath /cygdrive/c/Windows/System32
	export TEMP=~/AppData/Local/Temp
	export TMP=~/AppData/Local/Temp
fi

#-----------------------------------------------------------------------
# define terminal colors and prompts
#-----------------------------------------------------------------------
red='\e[0;31m'
RED='\e[1;31m'
blue='\e[0;34m'
BLUE='\e[1;34m'
cyan='\e[0;36m'
CYAN='\e[1;36m'
NC='\e[0m'								# No Color

# Looks best on a black background.....
echo -e "${CYAN}This is BASH ${RED}${BASH_VERSION%.*}${CYAN}${NC}"
date
function _exit() { # function to run upon exit of shell
	echo -e "${RED}Hasta la vista, baby${NC}"
}
trap _exit EXIT

PS1="\n${cyan}[`date +%m/%d` \@][\u@\h][\w]${NC}\n\$ "

#-----------------------------------------------------------------------
# aliases
#-----------------------------------------------------------------------
alias cp='cp -i'					# -> Prevents accidentally clobbering files.
if [[ ${BASH_VERSINFO[5]} == *cygwin* ]]; then
	alias clojure='java -cp $(cygpath -w ~/lib/java/clojure-1.6.0.jar) clojure.main'
else
	alias clojure='java -cp ~/lib/java/clojure-1.6.0.jar clojure.main'
fi
alias dnt='echo -e `date "+%A %B %d, %Y"`" "`date "+%I:%M %p"` > /dev/clipboard'
alias dtm='printf "[%s %s] " `date "+%y%m%d"` `date "+%H:%M"` > /dev/clipboard'
alias fn='{ alias && export -f; } | egrep "\(\)|alias" | sed "s/alias //ig" | cut -d= -f1 | sort'
alias gitlog='git log --pretty=format:"[%h] %ae, %ar: %s" --stat'
alias h='history'
alias j='jobs -l'
alias jjs='rlwrap $JAVA_HOME/bin/jjs'
alias l='ls --color=tty -A -B -F --ignore="desktop.ini" --ignore="NTUSER*" --ignore="ntuser*" --ignore=".*"'
alias ld='du -hs * | grep -e "^[0-9].*G\s" -e "^[0-9].*M\s" | sort -n -k 2,2 -s'
alias markdown='perl /usr/local/bin/markdown.pl '				# call Perl markdown
alias mkdir='mkdir -p'																		# Prevents accidentally clobbering files.
alias more='less' # more is less
alias mv='mv -i'																				# Prevents accidentally clobbering files.
alias mydiff='diff -ywEa --suppress-common-lines --minimal' # personal zip preferences
alias nospace="perl /usr/local/bin/rename 's/ /_' *"				# underscore all files in dir
alias r='fc -s' # execute last command
alias rm='rm -i'					# -> Prevents accidentally clobbering files.
alias rn='/usr/local/bin/rename '								# call Perl rename script
alias vi='vim'								# cygwin installs a minimal vi

#if [[ ${BASH_VERSINFO[0]} == 4 ]]; then
#		alias l='ls -A -B --color --group-directories-first -F --ignore="desktop.ini" --ignore="NTUSER*" --ignore="ntuser*"'
#fi

if [[ ${BASH_VERSINFO[5]} == *cygwin* ]]; then
	alias dow='date "+%A" > /dev/clipboard'
	alias fdt='date "+%B %d, %Y" > /dev/clipboard'
	alias tts='date "+%I:%M %p" > /dev/clipboard'
fi

#------------------------------------------------------------------------------------
# run on startup
#------------------------------------------------------------------------------------
# delete temporary files
nohup find $TEMP -type f -mtime +5 -exec rm {} \; > /tmp/${RANDOM}.out 2>&1&

fitterm () {																 # Truncate oversized lines on input. Mostly for display use. Example: grep foo log | fitterm
	cut -c 1-$( tput cols ) ;
}
export -f fitterm

# show today's Google calendar agenda
if [ -f /bin/google ] ; then
	 echo "Today's Agenda:"; google calendar today --fields title,when,where
fi

#------------------------------------------------------------------------------------
# functions 
#------------------------------------------------------------------------------------
function ll(){ ls -l "$@"| egrep "^d" ; ls -lXB "$@" 2>&-| egrep -v "^d|total "; }
export -f ll

# Find a file with a pattern in name:
function ff() { find . -type f -iname '*'$*'*' -ls ; }
export -f ff

# Find a file with pattern $1 in name and Execute $2 on it:
function fe() { find . -type f -iname '*'$1'*' -exec "${2:-file}" {} \;		; }
export -f fe

function fstr() { # find pattern in a set of filesand highlight them
	OPTIND=1
	local case=""
	local usage="fstr: find string in files.  Usage: fstr [-i] \"pattern\" [\"filename pattern\"] "
	while getopts :it opt; do
		case "$opt" in
			i) case="-i " ;;
			*) echo "$usage"; return;;
		esac
	done
	shift $(( $OPTIND - 1 ))
	if [ "$#" -lt 1 ]; then
		echo "$usage"
		return;
	fi
	local SMSO=$(tput smso)
	local RMSO=$(tput rmso)
	find . -type f -name "${2:-*}" -print0 | xargs -0 grep -sn ${case} "$1" 2>&- | \
	sed "s/$1/${SMSO}\0${RMSO}/gI" | more
}
export -f fstr

function cuttail() { # cut last n lines in file, 10 by default
	nlines=${2:-10}
	sed -n -e :a -e "1,${nlines}!{P;N;D;};N;ba" $1
}

function lowercase() { # move filenames to lowercase
	 for file ; do
		filename=${file##*/}
		case "$filename" in
		 */*) dirname==${file%/*} ;;
		 *) dirname=.;;
		esac
		nf=$(echo $filename | tr A-Z a-z)
		newname="${dirname}/${nf}"
		if [ "$nf" != "$filename" ]; then
		 mv "$file" "$newname"
		 echo "lowercase: $file --> $newname"
		else
		 echo "lowercase: $file not changed."
		fi
	done
}
export -f lowercase

function ccd {	# clear the screen, change directory, list contents
	clear
	cd "$1"
	l
}
export -f ccd

function dateprefix { # add YYYYMM to files in %CD%
	date_prefix=$(date + %Y%m)
	for file in *.*
	do
		mv $file		"$date_prefix ${file%.*}.${file##*.}"
	done
}

function extract () {
	if [ ! -f "$1" ] ; then
		echo "'$1' is not a valid file!"
		return 1
	fi

	# Assoc. array of commands for extracting archives
	declare -A xcmd
	xcmd=(
		[.tar.bz2]="tar xvjf"
		[.tar.gz]="tar xvzf"
		[.bz2]="bunzip2"
		[.rar]="unrar x"
		[.gz]="gunzip"
		[.tar]="tar xvf"
		[.zip]="unzip"
		[.Z]="uncompress"
		[.7z]="7z x"
	)
	# extension aliases
	xcmd[.tbz2]="${xcmd[.tar.bz2]}"
	xcmd[.tgz]="${xcmd[.tar.gz]}"

	# See which extension the given file uses
	fext=""
	for i in ${!xcmd[@]}; do
		if [ $(grep -o ".\{${#i}\}$" <<< $1) == "$i" ]; then
			fext="$i"
			break
		fi
	done

	# Die if we couldn't discover what archive type it is
	if [ -z "$fext" ]; then
		echo "don't know how to extract '$1'..."
		return 1
	fi

	# Extract & cd if we can
	fbase=$(basename "$1" "$fext")
	if ${xcmd[$fext]} "$1" && [ -d "$fbase" ]; then
		cd "$fbase"
	fi
}
export -f extract

function uppercase()		# move filenames to uppercase
{
	for file ; do
	filename=${file##*/}
	case "$filename" in
	*/*) dirname==${file%/*} ;;
	*) dirname=.;;
	esac
	nf=$(echo $filename | tr a-z A-Z)
	newname="${dirname}/${nf}"
	if [ "$nf" != "$filename" ]; then
		mv "$file" "$newname"
		echo "uppercase: $file --> $newname"
	else
		echo "uppercase: $file not changed."
	fi
	done
}
export -f uppercase

function swap() {				 # swap 2 filenames around
	local TMPFILE=tmp.$$
	mv "$1" $TMPFILE
	mv "$2" "$1"
	mv $TMPFILE "$2"
}
export -f swap

bak () { # save a copy of a file with a file stamp
	filename="$(basename "$1")"
	extension="${filename##*.}"
	filename="${filename%.*}"
	filetime=$(date -r "$1" +%Y%m%d$H%M%S)
	cp "$1" ${filename}_${filetime}.${extension}
}

function my_ps() { ps $@ -u $USER -o pid,%cpu,%mem,bsdtime,command ; }
export -f my_ps
function pp() { my_ps f | awk '!/awk/ && $0~var' var=${1:-".*"} ; }
export -f pp

function ii() { # get current host related info
	echo -e "\nYou are logged on ${RED}$HOST"
	echo -e "\nAdditionnal information:$NC " ; uname -a
	echo -e "\n${RED}Users logged on:$NC " ; w -h
	echo -e "\n${RED}Current date :$NC " ; date
	echo -e "\n${RED}Memory stats :$NC " ; free
	my_ip 2>&- ;
	echo -e "\n${RED}Local IP Address :$NC" ; echo ${MY_IP:-"Not connected"}
	echo -e "\n${RED}ISP Address :$NC" ; echo ${MY_ISP:-"Not connected"}
	echo
}
export -f ii

function repeat() { # repeat n times command
	local i max
	max=$1; shift;
	for ((i=1; i <= max ; i++)); do		# --> C-like syntax
		eval "$@";
	done
}
export -f repeat

function ask() {
	echo -n "$@" '[y/n] ' ; read ans
	case "$ans" in
	y*|Y*) return 0 ;;
	*) return 1 ;;
	esac
}
export -f ask

function cdb() {
	USAGE="Usage: cdb [-c|-g|-d|-l] [bookmark]" ;
	if		[ ! -e ~/.cd_bookmarks ] ; then
	mkdir ~/.cd_bookmarks
	fi

	case $1 in
		# create bookmark
		-c) shift
			if [ ! -f ~/.cd_bookmarks/$1 ] ; then
				echo "cd `pwd`" > ~/.cd_bookmarks/"$1" ;
			else
				echo "Try again! Looks like there is already a bookmark '$1'"
			fi
			;;
		# goto bookmark
		-g) shift
			if [ -f ~/.cd_bookmarks/$1 ] ; then
				source ~/.cd_bookmarks/"$1"
			else
				echo "Mmm...looks like your bookmark has spontaneously combusted. What I mean to say is that your bookmark does not exist." ;
			fi
			;;
		# delete bookmark
		-d) shift
			if [ -f ~/.cd_bookmarks/$1 ] ; then
				rm -rf ~/.cd_bookmarks/"$1" ;
			else
				echo "Oops, forgot to specify the bookmark" ;
			fi
			;;
		# list bookmarks
		-l) shift
			ls -l ~/.cd_bookmarks/ ;
			;;
		*) echo "$USAGE" ;
			;;
	esac
}
export -f cdb

function gvi() {
	/cygdrive/c/Progra~2/Vim/vim74/gvim.exe "$1" &
}
export -f gvi
